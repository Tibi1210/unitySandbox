#pragma kernel FractalNoiseCS

RWTexture2DArray<float4> _Result;
float _BaseFrequency;
int _OctaveCount;

struct OctaveParams {
    float lacunarity;
    float persistence;
    int rotation;
    float shift;
};
StructuredBuffer<OctaveParams> _Octaves;

float3 hash( float3 p ){                        
	p = float3( dot(p,float3(127.1,311.7, 74.7)),
			  dot(p,float3(269.5,183.3,246.1)),
			  dot(p,float3(113.5,271.9,124.6)));

	return -1.0 + 2.0*frac(sin(p)*43758.5453123);
}

// return value noise (in x) and its derivatives (in yzw)
float4 noised(float3 x){
    // grid
    float3 i = floor(x);
    float3 f = frac(x);
    
    // quintic interpolant
    float3 u = f*f*f*(f*(f*6.0-15.0)+10.0);
    float3 du = 30.0*f*f*(f*(f-2.0)+1.0);
   
    
    // gradients
    float3 ga = hash( i+float3(0.0,0.0,0.0) );
    float3 gb = hash( i+float3(1.0,0.0,0.0) );
    float3 gc = hash( i+float3(0.0,1.0,0.0) );
    float3 gd = hash( i+float3(1.0,1.0,0.0) );
    float3 ge = hash( i+float3(0.0,0.0,1.0) );
	float3 gf = hash( i+float3(1.0,0.0,1.0) );
    float3 gg = hash( i+float3(0.0,1.0,1.0) );
    float3 gh = hash( i+float3(1.0,1.0,1.0) );
    
    // projections
    float va = dot( ga, f-float3(0.0,0.0,0.0) );
    float vb = dot( gb, f-float3(1.0,0.0,0.0) );
    float vc = dot( gc, f-float3(0.0,1.0,0.0) );
    float vd = dot( gd, f-float3(1.0,1.0,0.0) );
    float ve = dot( ge, f-float3(0.0,0.0,1.0) );
    float vf = dot( gf, f-float3(1.0,0.0,1.0) );
    float vg = dot( gg, f-float3(0.0,1.0,1.0) );
    float vh = dot( gh, f-float3(1.0,1.0,1.0) );
	
    // interpolations
    return float4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value
                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives
                 du * (float3(vb,vc,ve) - va + u.yzx*float3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*float3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));
}



#define PI 3.14159265358979323846
float rad(int angle){
    return angle * (PI / 180);
}

float2x2 direction(float angle){
    return float2x2(normalize(float4(cos(angle),sin(angle),-sin(angle),cos(angle))));
}  

/**
 * @brief Main compute shader kernel that generates fractal noise with derivatives
 * @param id Thread ID containing the x,y coordinates to process
 * 
 * Generates fractal (multi-octave) Perlin noise by summing multiple octaves
 * with different frequencies and amplitudes. Stores both the final noise value
 * and its derivatives in the output texture.
 */
[numthreads(32, 32, 1)]
void FractalNoiseCS(uint3 id : SV_DispatchThreadID) {
    float2 uv = (id.xy + 0.5) / float2(256.0, 256.0);

    float total = 0;
    float3 derivative = 0;
    float amplitude = 1.0;
    float frequency = _BaseFrequency;
    
    for (int i = 0; i < _OctaveCount; i++) {

        amplitude *= _Octaves[i].persistence;
        frequency *= _Octaves[i].lacunarity;

        uv = mul(direction(rad(_Octaves[i].rotation)), uv) * frequency + _Octaves[i].shift;

        float4 noise = noised(float3(abs(uv), 1.0));
        total += noise.x * amplitude;
        derivative += noise.yzw * (amplitude);
    }

    _Result[uint3(id.xy, 0)] = float4(total, derivative);
}
